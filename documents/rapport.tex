\documentclass[]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{color}

\usepackage{amsmath}

\usepackage[left=2.5cm, right=2.5cm, top=2.5cm]{geometry}
\usepackage{multicol, float}

\usepackage{graphicx}
\graphicspath{{./medias/}}

\usepackage{tikz, pgfplots}
\usepackage[all]{xy}
\pgfplotsset{compat=1.5}

\title{Implantation Fonctionnelle \\ d'Algorithmes Géométriques en 3D \\
  \large Quickhull}
\author{Titouan Laurent - Master 1 parcours Image et 3D}
\date{}

\begin{document}

\maketitle

\includegraphics[width=5cm]{illus/illus0.png}
\includegraphics[width=5cm]{illus/illus1.png}
\includegraphics[width=5cm]{illus/illus2.png}

\tableofcontents

\section{Introduction}
\paragraph{Preuve assistée par ordinateur}
Prouver la correction d'un algorithme, c'est à dire démontrer formellement qu'il répond à des spécifications précises est une tâche qui se veut essentielle dans de nombreux domaines de l'informatique. Cela permet de s'assurer de sa robustesse et donc de celle des implantations qui en découlent.ggg

Cependant, il peut-être fastidieux de chercher à faire une démonstration formelle à la main, d'autant plus qu'en informatique l'écart entre une implantation donnée et sa description formelle représente une limite. Dans le cas des algorithmes géométriques, il y a l'introduction de difficultés supplémentaires, puisque l'on se retrouvera généralement à travailler aussi bien sur des notions topologiques qu'arithmétiques.

À partir de là, les outils outils de preuve automatique se présentent comme une solution viable. Ils permettent de démontrer des propriétés dans une implantation donnée d'un algorithme, et donc d'en prouver la correction. La contrainte étant que l'implantation doit être faite dans un style de programmation fonctionnel. Leur intérêt réside aussi dans le fait qu'on peut en extraire un programme certifié.

\paragraph{Application au calcul de l'enveloppe convexe}
Le calcul de l'enveloppe convexe d'un ensemble fini de points est un problème bien connu en géométrie et en informatique. Un certain nombre d'algorithmes existent pour le résoudre, et parmi ceux-ci Quickhull se veut être inspiré de Quicksort en proposant une approche de type diviser pour régner, lui assurant une complexité en $O(n\log{}n)$.

Par le passé, une implantation de Quickhull restreinte aux ensembles de points à 2 dimensions a été proposée et prouvée formellement. Seulement, la généralisation de Quickhull aux ensembles à 3 dimensions et plus, à partir de la version précédente, n'est pas une tâche triviale à cause des contraintes supplémentaires de visibilité (qu'on ne retrouve pas en 2 dimensions). Il faut également ajouter que les implantations en 3 dimensions existantes sont le pour la grande majorité faites dans un style de programmation impératif, et donc pas directement adapté à la preuve automatique.

\paragraph{}
Mon travail de recherche a donc pour objectif d'explorer ce qui est envisageable en terme d'implantation en style de programmation fonctionnel, de preuve mais aussi d'aide à la visualisation de l'algorithme Quickhull en 3 dimensions.

\section{Choix d'un langage de programmation}
Pour ce sujet le langage de programmation retenu est celui de Coq. Coq est un assistant à la construction de preuves automatiques, codées avec une syntaxe qui lui est propre, en paradigme fonctionnel.

Seulement, ici il présente au moins quatre limitations importantes :
\begin{itemize}
	\item C'est un langage plutôt austère à prendre en main, sa syntaxe est loin d'être évidente et donc il n'est que peu pratique pour développer rapidement et aisément.
	\item Il ne permet nativement pas de faire du dessin graphique, ce qui serait pourtant très pratique pour vérifier visuellement le bon fonctionnement des programmes développés.
	\item Il en est de même pour la lecture et l'écriture de fichiers (pour stocker l'enveloppe convexe par exemple).
	\item Coq n'est pas un environnement dédié à l'exécution de programmes. En effet il n'est que très peu performant en temps et en capacités de calcul (même lorsqu'il s'agit de faire des opérations arithmétiques sur de simples entiers non signés).
\end{itemize}

\subparagraph{}
J'ai donc porté mon choix sur le JavaScript, et ce pour les raisons suivantes :
\begin{itemize}
	\item Mis à part Coq, je n'ai jamais utilisé de langage purement fonctionnel jusque-là.
	\item JavaScript est \textbf{multi-paradigme}, et donc il permet nativement de développer dans un style de \textbf{programmation fonctionnel}.
	\item C'est un langage que je connais particulièrement bien.
	\item JavaScript est adapté à la lecture/écriture de fichiers.
	\item JavaScript intègre nativement des outils d'\textbf{rendu graphique} (WebGL et dessin dans un Canvas avec des instructions simples).
\end{itemize}

\section{Implantation de Quickhull en 2D}
Avant de commencer à directement travailler sur Quickhull en 3 dimensions, il m'est bien plus évident de déjà comprendre le cas restreint (et donc plus simple) aux ensembles à deux dimensions, ne serait-ce que pour en cerner les caractéristiques principales.

\subsection{Principe général}

\paragraph{}
L'algorithme Quickhull en 2 dimensions pourrait être qualifié de "cas d'école" de la technique du \emph{diviser pour régner}. Pour s'en convaincre on peut reprendre l'exemple suivant, illustrant des étapes successives de la construction de l'enveloppe.

\includegraphics[width=5cm]{qh2d/geogebra-export.png}
\includegraphics[width=5cm]{qh2d/geogebra-export2.png}
\includegraphics[width=5cm]{qh2d/geogebra-export3.png}

Considérons que l'on dispose des points suivants. Supposons également qu'on sait que les points $A$ et $B$ (en rouge) appartiennent à l'enveloppe convexe (arête en pointillé). La prochaine étape de l'algorithme est alors de déterminer le point le plus extrême (le plus éloigné) de l'arête $AB$ : on trouve le point $C$ (en vert).

\includegraphics[width=6cm]{qh2d/geogebra-export4.png}

Sachant la nouvelle enveloppe obtenue, on peut alors procéder à la division du problème en deux sous-problèmes (plus petits) : pour chaque arête nouvellement créée (ici $AC$ et $CB$), on forme un sous-ensemble de points (entourés en bleu) en ne gardant que ceux qui sont visibles depuis l'arête en question. Ici $H$ et $G$ ne sont pas visibles (visbilité orientée) ni par $AC$, ni par $CB$, donc ils ne font pas partie de l'enveloppe convexe.

On peut alors récursivement appliquer le même algorithme sur les 2 sous-ensembles générés (entourés en bleu ici) par rapport à leur arête respective ($AC$ et $CB$).

L'enveloppe convexe est alors construite par les opérations de combinaison des données de retour des sous-appels récursifs (il s'agit basiquement d'une liste ordonnée des points appartenant à l'enveloppe convexe).

\paragraph{Note :}
Il est important de noter qu'un point fort de cet algorithme réside dans le choix du point le plus extrême par rapport à une arête. Avec cette méthode on s'assure d'avoir deux sous-ensembles disjoints de points associés aux nouvelles arêtes, et donc on peut appliquer le même algorithme sur les 2 sous-ensembles.

Si on n'avait pas l'assurance que les sous-ensembles sont disjoints, on ne pourrait tout simplement pas faire l'opération de division, et donc pas de \emph{diviser pour régner}.

\paragraph{}
La première étape de Quickhull en 2D (et donc des premiers appels récursifs) peut varier en fonction des implantations. Pour ma part j'ai choisi celle qui consiste à prendre les deux points sur un même axe ($x$ ou $y$) qui sont les plus éloignés l'un de l'autre. On obtient une arête dont chacune des extrêmités appartient à l'enveloppe convexe. Il suffit alors de lancer l'algorithme précédent en partant successivement de chacun des (2) côtés de l'arête.

\subsection{Démo visuelle}

\section{Implantation de Quickhull en 3D}

\subsection{Principe et spécificités}
Au-delà de 2 dimensions, l'algorithme Quickhull est nettement plus complexe à implanter. Déjà, en trois dimensions une enveloppe convexe n'est plus une suite d'arêtes mises bout à bout, mais un maillage surfacique triangulaire. Ce qui va demander de penser à une nouvelle structure de données adaptée.

De plus, il n'est plus possible de faire un algorithme en \emph{diviser pour régner}, et pour le comprendre on va regarder un exemple similaire à celui donné pour Quickhull 2D.

\paragraph{}
\emph{Pour aider à la lisibilité des points dans l'espace 3D, le triangle $ABC$ est sur le plan de la grille, et les points $D$ à $H$ sont représentés avec leur droite verticale.}

\includegraphics[width=5cm]{qh3d/geogebra-export3.png}
\includegraphics[width=5cm]{qh3d/geogebra-export4.png}
\includegraphics[width=5cm]{qh3d/geogebra-export5.png}

Considérons que l'on dispose du triangle $ABC$ : une face de l'enveloppe convexe, et des points $D$ à $H$ comme étant l'ensemble des points non traités. Comme pour Quickhull 2D, on va déterminer le point le plus extrême (le plus éloigné) de la face $ABC$ : on trouve le point $D$ (en vert).

La nouvelle enveloppe est alors obtenue par la construction des trois faces $ABD$, $ACD$, $BCD$. Le prédicat de visibilité nous permet de déterminer que le point $G$ (en gris) n'appartient pas à l'enveloppe convexe car non visible des trois faces.

\paragraph{}
Tout semble bien se passer, jusqu'à l'étape de la division :

\includegraphics[width=6cm]{qh3d/geogebra-export6.png}
\includegraphics[width=6cm]{qh3d/geogebra-export7.png}

Sur ces deux vues on ne fait \textbf{que} de déplacer la caméra autour du solide.
En alignant sur une seule droite successivement les points $A$, $D$ et $C$, puis les points $B$, $D$ et $A$, on peut voir que le point $F$ est visible \textbf{simultanément} par deux des faces nouvellement créées.

Cette particularité nous interdit de faire l'étape de la division pour \emph{diviser pour régner}. On comprend également que contrairement à la version 2D où l'on se contentait de modifier supprimer une arête à la fois pour la subdiviser en de nouvelles sous-arêtes, ici on devra parfois supprimer plusieurs faces (car visibles depuis un point extrême) pour reconstruire un certain nombre de faces supplémentaires (l'exemple donné ici est un cas particulier plutôt simple car le point extrême $D$ ne voit qu'une seule face : le triangle $ABC$).

\subsection{Adaptation de l'algorithme}

Puisque l'on ne peut pas faire de \emph{diviser pour régner}, l'algorithme doit être pensé différemment. Je me suis basé sur le pseudo-code donné dans (citer référence) qui propose une généralisation pour les dimensions supérieures à 2.

\paragraph{}
La boucle principale de l'algorithme suit ces étapes :
\begin{itemize}
	\item On choisit une face parmi les faces de l'enveloppe convexe courante dont le sous-ensembles de points non-traités associé est non-vide.
	\item On prend le point le plus extrême (le plus éloigné) par rapport à ladite face depuis le sous-ensemble de points associé.
	\item On supprime \textbf{toutes} les faces visibles de l'enveloppe convexe depuis ce point.
	\item On reconstruit l'enveloppe convexe en formant des faces (triangles) entre ce point et le bord du trou laissé à l'étape précédente.
	\item On recalcule le sous-ensemble de points associé à la face courante par rapport à la nouvelle enveloppe obtenue (étape qui est loin d'être triviale). On devrait obtenir un nouveau sous-ensemble de points par face nouvellement ajoutée.
	\item Ré-itérer jusqu'à ce qu'il n'y ait plus de sous-ensemble non-vide associé à l'une des faces de l'enveloppe convexe.
\end{itemize}

\paragraph{}
La première étape de l'algorithme consiste (à la manière de Quickhull 2D) à trouver un solide minimal qui formera l'enveloppe convexe initiale. Celui-ci est formé de 4 faces (soient 4 points), sélectionnés suivant la méthode suivante (ref adapté du site) :
\begin{itemize}
	\item On cherche deux points les plus éloignés sur deux axes (parmi $x$, $y$ et $z$) parmi l'ensemble de points.
	\item Avec l'arête formée des deux points précédent, on cherche un troisième point le plus éloigné de ce segment.
	\item On dispose maintenant d'une face (un triangle) depuis laquelle on va chercher un quatrième point qui en est le plus éloigné.
	\item On peut dès lors construire le tétrahèdre formé par ces 4 points.
	\item On attribue (arbitrairement) à chaque face un sous-ensemble de points qui lui sont visibles.
\end{itemize}

\paragraph{}
On se rend compte que cette fois-ci il va nous falloir une structure de données pour représenter les sous-ensembles de points associés aux faces. Celle-ci sera appelée $oset$ pour \emph{outside set} par la suite (et $osubset$ pour \emph{outside subset}).

\subsection{Structures de données}
\subsubsection{Données d'entrées}
Un $vec3$ permet de modéliser aussi bien un point qu'un vecteur dans l'espace 3D. Les composantes sont données dans l'ordre usuel $x$, $y$ et $z$ (avec $x, y, z \in \mathbf{R}$).\\
Dans notre implantation, on considèrera une simple liste ordonnée des $n$ points (représentée par la variable globale $GLOBAL\_V\_LIST$) comme étant les données d'entrée du problème à résoudre.

\subsubsection{Stockage et manipulation de l'enveloppe convexe en mémoire}
La structure en liste de demi-arêtes orientées (doubly connected edge list, abrégé DCEL) est parmi les plus communes qu'il soit dès lors que l'on souhaite modéliser un maillage topologique.\\
Ici on implante une version restreinte de cette dernière, puisqu'elle permet de créer maillages triangulaires uniquement — ce qui correspond à notre besoin.

\paragraph{Demi-arête}
Une $he$ (abrévation de halfedge, ou demi-arête) est une structure de données disposant d'informations sur elle-même et son voisinage topologique. Celles-ci sont les suivantes :
\begin{itemize}
	\item $index \in \mathbf{Z}$, un identifiant unique pour la demi-arête, avec :
	      \[
		      \left\{
		      \begin{array}{ll}
			      index = -1   & \mbox{est une demi-arête nulle} \\
			      index \geq 0 & \mbox{sinon}
		      \end{array}
		      \right.
	      \]
	\item $opposite \in \mathbf{Z}$, l'identifiant de la demi-arête opposée, avec :
	      \[
		      \left\{
		      \begin{array}{ll}
			      opposite = -1   & \text{est une demi-arête du bord} \\
			      opposite \geq 0 & \text{sinon}
		      \end{array}
		      \right.
	      \]
	\item $vertex \in \mathbf{N}$, l'indice du sommet incident dont elle est issue.
\end{itemize}

\paragraph{Maillage triangulaire}
Une $dcel$ permet la modélisation d'un maillage topologique triangulaire. Elle dispose des attributs suivants :
\begin{itemize}
	\item $he\_list$, une liste de $he$.
	\item $available\_he\_index \in \mathbf{N}$, le prochain indice non attribué à une $he$ de la liste.
\end{itemize}

\paragraph{Exemple simple en 2D} :

\begin{figure}[H]
	\[\begin{aligned}[c]
			\entrymodifiers={+[o][F]}
			\renewcommand{\labelstyle}{\textstyle}
			\xymatrix@=4em @L=.25ex{
			{}
			\ar @^{-} [d]
			\ar @^{-} [dr]
			 & {}
			\ar @^{-} [l]
			\\ {}
			\ar @^{-} [r]
			 & {}
			\ar @^{-} [u]
			}
		\end{aligned}\rightarrow\begin{aligned}[c]
			\xymatrix@=4em @L=.25ex{
			{\color{red}0}
			\ar @<.25ex> @^{->} [d] |{\color{blue}0}
			\ar @<.25ex> @^{->} [dr] ^{\color{blue}4}
			 & {\color{red}1}
			\ar @<.25ex> @^{->} [l] |{\color{blue}3}
			\\ {\color{red}2}
			\ar @<.25ex> @^{->} [r] |{\color{blue}1}
			 & {\color{red}3}
			\ar @<.25ex> @^{->} [ul] ^{\color{blue}2}
			\ar @<.25ex> @^{->} [u] |{\color{blue}5}
			}
		\end{aligned}\]
	\caption{Un maillage simple et un indiçage correspondant.}
	\label{maillage_simple}
\end{figure}

\begin{figure}[H]
	\[
		\begin{aligned}[c]
			\begin{array}{l}
				\begin{tabular}{|c|c|c|c|}
					\hline
					index         & opposite      & vertex       \\
					\hline
					\color{blue}0 & -1            & \color{red}0 \\
					\hline
					\color{blue}1 & -1            & \color{red}2 \\
					\hline
					\color{blue}2 & \color{blue}4 & \color{red}3 \\
					\hline
					\color{blue}3 & -1            & \color{red}1 \\
					\hline
					\color{blue}4 & \color{blue}2 & \color{red}0 \\
					\hline
					\color{blue}5 & -1            & \color{red}3 \\
					\hline
				\end{tabular} \\\\
				available\_he\_index\textbf{ : }6
			\end{array}
		\end{aligned}
		\begin{aligned}[c]
			\begin{tabular}{|c|c|}
				\hline
				Indice       & Coordonnées \\
				\hline
				\color{red}0 & (0,0)       \\
				\hline
				\color{red}1 & (1,0)       \\
				\hline
				\color{red}2 & (1,1)       \\
				\hline
				\color{red}3 & (0,1)       \\
				\hline
			\end{tabular}
		\end{aligned}
	\]
	\caption{Structure $dcel$ à gauche et la table des sommets à droite.\\Note : $avaiable\_he\_index$ est un indice disponible pour la prochaine demi-arête qui pourrait être ajoutée à la $dcel$.}
	\label{maillage_simple_struct_associee}
\end{figure}

Considérons le maillage de la Figure~\ref{maillage_simple}. Une structure $dcel$ associée valide serait alors telle que celle présentée Figure~\ref{maillage_simple_struct_associee}.

\paragraph*{Note :} si les numéros d'indices choisis pour les demi-arêtes sont ici plus ou moins arbitraires, la structure $dcel$ impose tout de même des contraintes comme nous allons le voir.

\paragraph{Ajout et retrait d'une face dans une $dcel$}
Il s'agit des deux seules opérations de modification d'une $dcel$.

\subsubsection{Stockage et manipulation de l'ensemble de points extérieurs associés aux faces}
\paragraph*{Sous-ensemble de points extérieurs — $osubset$}
Un sous-ensemble de points extérieurs (outside subset) est une structure de données à deux champs :
\begin{itemize}
	\item $face\_index \in \mathbf{N}$, l'identifiant unique d'une face.
	\item $list \in \mathbf{N}$, l'ensemble des points extérieurs à la face $face\_index$, représentés par leur indice dans $GLOBAL\_V\_LIST$.
\end{itemize}

\paragraph*{Ensemble de points extérieurs — $oset$}
L'ensemble de points extérieurs (outside set) n'est rien d'autre qu'une liste d'$osubset$, chacune associée à une unique face (et son ensemble de points extérieurs associé).

\subsection{Évaluation des performances}
Lors d'une itération dans l'algorithme de calcul d'enveloppe convexe 3D, deux instructions successives amènent à devoir choisir un élément parmi un ensemble — sachant que tous conduisent à la terminaison du programme et à la construction d'une enveloppe convexe valide. Dès lors l'utilisation d'heuristiques est envisageable, et cette partie porte sur la comparaison des performances en temps de calcul en fonction des méthodes employées.

Dans la prochaine section on s'intéresse à la sélection du prochain sous-ensemble de points non-vide (et donc implicitement d'une face du polygone convexe en cours de construction).
Tandis qu'à la section suivante on s'intéresse à la sélection du point parmi ceux du sous-ensemble choisit précédemment.

Les tests ont été conduits en moyennant le temps de calcul pour 50 échantillons de points générés aléatoirement (répartition spatiale aléatoire et uniforme).

\paragraph{Heuristique sur le choix du point} :
\begin{figure}[H]\begin{tikzpicture}
		\begin{axis}[
				title = {},
				xlabel = {Nombre de points en entrée},
				ylabel = {Temps de calcul (ms)},
				legend entries={Point le plus éloigné,Premier point de la liste},
				legend style={at={(0,1)},anchor=north west}
			]
			\addplot+[blue] table {medias/normal.dat};
			\addplot table {medias/not_extreme_point.dat};
		\end{axis}
	\end{tikzpicture}
	\caption{La courbe bleue montre ici que la stratégie consistant à prendre le point le plus éloigné du plan courant offre de meilleures performances en temps que celle où l'on prend naïvement le premier point de la liste (courbe rouge).}
\end{figure}

\paragraph{Heuristique sur le choix du sous-ensemble} :
\begin{figure}[H]\begin{tikzpicture}
		\begin{axis}[
				title = {},
				xlabel = {Nombre de points en entrée},
				ylabel = {Temps de calcul (ms)},
				legend entries={Premier sous-ensemble,Plus petit sous-ensemble,Plus grand sous-ensemble},
				legend style={at={(0,1)},anchor=north west},
			]
			\addplot+[blue] table {medias/normal.dat};
			\addplot table {medias/smallest_osubset.dat};
			\addplot table {medias/largest_osubset.dat};
		\end{axis}\end{tikzpicture}
	\caption{
		De manière prévisible choisir le plus petit sous-ensemble à chaque itération nuit aux performances de l'algorithme (courbe rouge). En effet en ne prenant à chaque fois que un plus petit sous-ensemble de $n$ points (avec $n > 0$), on se restreint alors à retirer de l'ensemble total $n$ points au mieux à cette itération.\\
		Il est intéressant de noter ici que prendre le plus grand sous-ensemble (courbe brune) est plus performant que de choisir le premier de la liste (courbe bleue), mais le gain n'est pas aussi significatif que ce qu'on a montré précédemment.
	}
\end{figure}

\subsection{Démo visuelle}

\section{Implantation d'une étape de Quickhull 3D en Coq et extraction en Haskell}

\section{Conclusion}
\subsection{Si c'était à refaire}
\subsection{Pour continuer}

\end{document}